g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
B = B - solve(H)%*%G
cat('G:', G, 'L:', L, '\n')
}
while (tol < min(G)){
beta1 = B[1]
beta2 = B[2]
L = 1/2*log(2/pi) - 1/2*log(sig2) - 1/(2*sig2*T)*sum( (y2 - beta1 - beta2*x2)^2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
B = B - solve(H)%*%G
cat('G:', G, 'L:', L, '\n')
}
sig2 = 1.5
T = length(x2)
beta1 = 0.11
beta2 = -100
B = rbind(beta1, beta2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
tol = 1/1e5
while (tol < min(G)){
beta1 = B[1]
beta2 = B[2]
L = 1/2*log(2/pi) - 1/2*log(sig2) - 1/(2*sig2*T)*sum( (y2 - beta1 - beta2*x2)^2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
B = B - solve(H)%*%G
cat('G:', G, 'L:', L, '\n')
}
beta1 = 0.11
beta2 = 0
B = rbind(beta1, beta2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
tol = 1/1e5
while (tol < min(G)){
beta1 = B[1]
beta2 = B[2]
L = 1/2*log(2/pi) - 1/2*log(sig2) - 1/(2*sig2*T)*sum( (y2 - beta1 - beta2*x2)^2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
B = B - solve(H)%*%G
cat('G:', G, 'L:', L, '\n')
}
while (tol < min(G)){
beta1 = B[1]
beta2 = B[2]
L = 1/2*log(2/pi) - 1/2*log(sig2) - 1/(2*sig2*T)*sum( (y2 - beta1 - beta2*x2)^2)
g1 = 1/(sig2*T) *sum(y2 - beta1 - beta2*x2)
h1 = -1/(T*sig2)
g2 = 1/(T*sig2) * sum(y2*x2 - beta1*x2 - beta2*x2^2)
h2 = -beta2/(T*sig2) * sum(x2^2)
G = rbind(g1, g2)
H = matrix(c(h1, 0, 0, h2), nrow = 2, ncol = 2)
B = B - solve(H)%*%G
cat('G:', G, 'L:', L, '\n')
}
exp(0.73654)
exp(0.73654)
exp(0.7198)
17^2
289-4*52
4*13
exp(0.248)
exp(0.1528)
exp(0.1523)
186/26
exp(-2.16)
exp(-2.19)
exp(-2.29)
exp(-2.38)
exp(-238)
exp(-23.8)
exp(-5)
exp(-6)
exp(-7)
exp(-8)
exp(-2.5)
exp(-3.36)
***
plot(cars)
x = seq(-5, 5, 0.1)
y = x^(-0.4)
plot(y, x)
plot(y, x, type='line')
plot( x, y, type='line')
y = x^(-0.8)
x = seq(-5, 5, 0.1)
y = x^(-0.8)
plot( x, y, type='line')
plot( x, y, type='l')
y = x^(-0.1)
plot( x, y, type='l')
65*418
exp(-6.13)
0.03*26
0.03*26000
log(3)
log(-3)
log(1/3)
-log(1/3)
1.3/0.7
-(1 + 0.3)/0.7
0.4^10
0.4^100
y = c(1, 4, 3, 5, 7)
x = c(0.5, 1, 2, 11, 2)
y = c(1, 4, 3, 5, 7)
x = c(0.5, 1, 2, 11, 2)
df = data.frame(y, x)
df[1]
pars = c(1, 2)
otim = function(data, pars){
y_hat = pars[1] + pars[2]*df[2]
y_hat_med = mean(y_hat)
y_mean = mean(df[1])
dist = y_hat_med - y_med
}
otim(df, pars)
mean(df[1])
df[1]
str(df[1])
str(df)
mean(df[1])
mean(as.numeric(df[1]))
mean(as.numeric(df[1]))
mean(y)
mean(df[,1])
otim = function(data, pars){
y_hat = pars[1] + pars[2]*df[,2]
y_hat_med = mean(y_hat)
y_mean = mean(df[,1])
dist = abs(y_hat_med - y_med)
}
otim(df, pars)
otim = function(data, pars){
y_hat = pars[1] + pars[2]*df[,2]
y_hat_med = mean(y_hat)
y_med = mean(df[,1])
dist = abs(y_hat_med - y_med)
}
otim(df, pars)
otim = function(data, pars){
y_hat = pars[1] + pars[2]*df[,2]
y_hat_med = mean(y_hat)
y_med = mean(df[,1])
dist = abs(y_hat_med - y_med)
return(dist)
}
otim(df, pars)
library(optimx)
optim(par = pars, fn = otim, data=df)
lm(y~x)
sample('cara', 'coroa')
sample('cara', 'coroa')
sample('cara', 'coroa', 1)
a = c('cara', 'coroa')
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
sample(a, 1)
for(i in 1,100){
print(sample(a, 1))
}
for(i in 1,100){
print(sample(a, 1))
}
for(i in 1:100){
print(sample(a, 1))
}
for(i in 1:100){
print(sample(a, 1))
}
a = c(1, 2, 3, , 5)
a = c(1, 2, 3,'NaN', 5)
a
is.na(a)
is.nan(a)
a = c(1, 2, 3,., 5)
a = c(1, 2, 3, , 5)
a = c(1, 2, 3, NaN, 5)
is.nan(a)
mean(a, na.rm = T)
11/4
mean(a)
index = is.nan(a)==FALSE
a[index]
a[1]
a[1:3]
summary(a)
ifelse(is.na(a)==T, a=mean(a, na.rm = T), a)
mean(a, na.rm = T)
ifelse(is.na(a)==T, a = mean(a, na.rm = T), a)
mean(a, na.rm = T)
b = mean(a, na.rm = T)
ifelse(is.na(a)==T, a = b, a)
ifelse(is.na(a) = T, a = b, a)
ifelse(is.na(a) == T, a == b, a)
ifelse(is.na(a) == T, a == b, a)
ifelse(is.na(a) == T, a = b, a)
ifelse(is.na(a) == T, a = b, a=a)
ifelse(is.na(a) == T, b, a)
setwd("D:/Curso de R")
vec = c(2, 22, 34, 0, 67,3, 4, 6, 7, 80)
vec[1:5]
sqrt(vec)
sin(vec)
log(vec)
cos(vec)
vec1 = c('b', 'nn', 'k')
is.character(vec1)
vec2 = c(3, 'b', 'nn', 'k')
typeof(vec2)
vec + 2
2*vec
sqrt(vec, 3)
vec^(1/3)
vec3 = c(NaN, 3, 4, 6, 7, 8)
mean(vec3)
mean(vec3, na.rm = T)
is.na(vec3)
mean(vec3, na.rm = T)
na.omit(vec3)
na.omit(vec3)
as.numeric( na.omit(vec3) )
index = is.na(vec3) == FALSE
vec3[index]
summary(vec3, na.rm=T)
summary(vec3)
sd(vec3)
sd(vec3, na.rm=T)
seq(1,10) # 1 a 10
seq(1,10, 2)  # from 1 to 10 jumping from 2 to 2
seq(10,1, -2) # from 10 to 1 jumping from 2 to 2
rep(c(1, 3), 4)
rep(10, 5) # repeat 10 five times
rep(c(1,2, 3), c(3, 2, 1))
v1 = c('learn', 'r', 'funny')
v2 = c('very', 'easy', 'now')
v3 = c('sometimes', 'very', 'hard')
v4 = c(1, 2, 3)
B = rbind(v1, v2,v3,v4)       #or
B
B = cbind(v1, v2,v3,v4)
B
c1 = seq(1, 5,1)
c2 = rnorm(5)
c3 = seq(-44, -40, 1)
C = rbind(c1,c2,c3)
nr = c('j', 'k', 'l')
nr = c('j', 'k', 'l')
nc = c('l1', 'l2', 'l3', 'l4', 'l5')
colnames(C) = nc
rownames(C) = nr
C
x1 = c(2, 1, 5, 7, 8, 0, 2, 1)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x = cbind(x1, x2)
y = c(1, 5, 2, 3, 7, 32, 2, 0)
l = 0.5
library(matlib) # to use inv function
b = inv(t(x)%*%x)%*%t(x)%*%y   # inv(t(x)) inverse of tranpose x matrix
b
reg = lm(y ~x1 + x2 - 1)  # -1 ommit intercept
summary(reg)
b
source('D:/Git projects/college_works/Bayesian Simulation/logit.R')
plot(mod1_sim, ask = T)
windows()
plot(mod1_sim, ask = T)
summary(mod1_sim)
coef =  colMeans(mod1_sim)
coef =  colMeans(mod1_sim)
plot(mod1_sim, ask = T)
coef =  colMeans(mod1_sim)
colMeans(mod1_sim)
coef =  colMeans(mod1_csim)
coef =  colMeans(model_csim)
coef
summary(reg)
reg = glm(r ~ X, data=df, family=binomial(link = 'logit'))
summary(reg)
coef
coef['int']
coef['int'] + X%*%coef
coef['int'] + X%*%coef[-7]
1/(coef['int'] + X%*%coef[-7])
1/1 + exp(coef['int'] + X%*%coef[-7])
1/(1 + exp(coef['int'] + X%*%coef[-7]) )
curve(exp(x))
1/(1 - exp(coef['int'] + X%*%coef[-7]) )
1/(1 + exp(-coef['int'] - X%*%coef[-7]) )
y_hat = 1/(1 + exp(-coef['int'] - X%*%coef[-7]) )
plot(df$r, y_hat)
plot(y_hat, df$r)
plot(y_hat, jitter(df$r))
rep(0,7)
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
jitter(rep(0,7))
plot(y_hat, jitter(df$r))
table(y_hat>0.5, df$r)
tab = table(y_hat>0.5, df$r)
sum(diag(tab))/sum(tab)
setwd("D:/Git projects/college_works/Bayesian Simulation")
library('COUNT')
install.packages('COUNT')
library('COUNT')
data("badhealth")
data("badhealth")
head(badhealth)
vec = c(NULL, 1 , 4)
is.na(vec)
is.null(vecc)
is.null(vec)
any(is.nan(badhealth))
any(is.na(badhealth))
hist(badhealth$numvisit, breaks = 25, col = 'lightgreen')
hist(badhealth$numvisit, breaks = 20, col = 'lightgreen')
hist(badhealth$numvisit, breaks = 20, col = 'lightgreen', probability = T)
View(badhealth)
View(badhealth)
plot(jitter(log(numvist))~ jitter(age), data=badhealth, subset =badh==0&numvisit>0 )
plot(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==0&numvisit>0 )
points(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==0&numvisit>0, col='red' )
plot(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==0&numvisit>0 )
points(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==1&numvisit>0, col='red' )
points(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==1&numvisit>0, col='red', lty=19 )
plot(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==0&numvisit>0 )
points(jitter(log(numvisit))~ jitter(age), data=badhealth, subset =badh==1&numvisit>0, col='red', lty=19 )
library(rjags)
mod_string = 'model{
for (i in 1:length(numvisit)) {
numvisit[i] ~ dpois(lam[i])
log(lam[i]) = int + b_badh*badh[i] + b_age*age[i] + b_intx*age[i]*badh[i]
}
int ~ dnorm(0, 1/1e6)
b_badh ~ dnorm(0, 1/1e4)
b_age ~ dnorm(0, 1/1e4)
b_intx ~ dnorm(0, 1/1e4)
}'
set.seed(102)
data_jags = as.list(badhealth)
params = c('int', 'b_badh', 'b_age', 'b_intx')
mod = jags.model(textConnection(mod_string),
data=data_jags, n.chains = 3)
update(mod, 1e3)
mod_sim = coda.samples(model = mod,
variable.names = params,
n.iter = 5e3)
mod_csim = as.mcmc(do.call(rbind, mod_sim))
plot(mod_sim)
windows()
plot(mod_sim)
gelman.diag(mod_sim)
gelman.diag(mod_sim)
gelman.plot(mod_sim)
dic.samples(mod, n.iter = 3)
dic = dic.samples(mod, n.iter = 3)
pmed = apply(mod_csim, 2, median)
pmed
head(mod_csim)
seq(1, 1e6, 10)
seq(1, 1e6, 9)
seq(1, 1e6, 10)
seq(0, 1e6, 10)
seq(1, 1e6, x^10)
PG = function(){
pg = 1
for (i in 1:1e6) {
pg[i] = pg*10
}
}
PG()
PG = function(){
pg = 1
for (i in 1:1e6) {
pg[i] = pg[i-1]*10
return(pg)
}
}
PG()
PG = function(){
pg = 1
for (i in 1:1e6) {
pg[i] = pg*10
pg = pg[i]
return(pg)
}
}
PG()
PG = function(){
pg = 1
for (i in 1:1e6) {
pg[i] = pg*10
pg = pg[i]
}
return(pg)
}
PG()
PG = function(){
k = 1
pg = c()
for (i in 1:1e6) {
pg[i] = k*10
k = pg[i]
}
return(pg)
}
PG()
PG = function(){
k = 1
pg = c()
for (i in 1:10) {
pg[i] = k*10
k = pg[i]
}
return(pg)
}
PG()
PG = function(){
k = 1
pg = c()
for (i in 1:6) {
pg[i] = k*10
k = pg[i]
}
return(pg)
}
PG()
PG = function(){
k = 1
pg = c(1)
for (i in 1:6) {
pg[i+1] = k*10
k = pg[i+1]
}
return(pg)
}
PG()
pg = PG()
pg
log(pg)
(log(pg))(1/2)
(log(pg))^(1/2)
sum( (log(pg))^(1/2) )
prod(pg)
x = c(1, 2, 5)
prod(x)
prod(x[1])
prod(x[2])
prod(x[3])
gamma(x[3])
gamma(x[3]+1)
gamma(x+1)
x = c(1, 2, 5, 4)
gamma(x+1)
pi
